# MongoDB (NoSQL)

# Understanding MongoDB: A Comprehensive Guide

MongoDB is a popular NoSQL database that stores data in flexible, JSON-like documents. It offers high performance, high availability, and easy scalability.

## 1. Database Creation and Management

In MongoDB, databases and collections are created automatically when you first store data.

```jsx
// Switch to or create a database
use myDatabase

// Check current database
db

```

## 2. Collections

Collections in MongoDB are analogous to tables in relational databases, but without a fixed schema.

```jsx
// Create a collection explicitly
db.createCollection("users")

// Create a collection implicitly by inserting data
db.products.insert({ name: "Laptop", price: 999 })

```

## 3. Document Operations (CRUD)

### 3.1 Inserting Documents

MongoDB provides multiple ways to insert documents into collections:

```jsx
// Insert a single document
db.users.insertOne({
    name: "John Doe",
    email: "john@example.com",
    age: 30
})

// Insert multiple documents
db.users.insertMany([
    { name: "Jane Smith", email: "jane@example.com", age: 25 },
    { name: "Bob Johnson", email: "bob@example.com", age: 35 }
])

```

### 3.2 Query Operators

MongoDB offers powerful query capabilities for finding documents:

```jsx
// Basic find operations
db.users.find({ age: { $gt: 25 } })  // Greater than
db.users.find({ age: { $lt: 30 } })  // Less than
db.users.find({ name: { $in: ["John", "Jane"] } })  // In array
db.users.find({
    $and: [
        { age: { $gte: 25 } },
        { age: { $lte: 35 } }
    ]
})

```

### 3.3 Update Operators

Various operators are available for updating documents:

```jsx
// Update a single document
db.users.updateOne(
    { name: "John Doe" },
    { $set: { age: 31 } }
)

// Update multiple documents
db.users.updateMany(
    { age: { $lt: 30 } },
    { $inc: { age: 1 } }
)

// Array operators
db.users.updateOne(
    { name: "John Doe" },
    { $push: { hobbies: "reading" } }
)

```

### 3.4 Delete Operations

```jsx
// Delete a single document
db.users.deleteOne({ name: "John Doe" })

// Delete multiple documents
db.users.deleteMany({ age: { $lt: 25 } })

// Delete all documents in a collection
db.users.deleteMany({})

```

## 4. Indexing

Indexes improve query performance and can be created on any field or combination of fields:

```jsx
// Create a single field index
db.users.createIndex({ email: 1 })  // 1 for ascending, -1 for descending

// Create a compound index
db.users.createIndex({ name: 1, age: -1 })

// Create a unique index
db.users.createIndex({ email: 1 }, { unique: true })

// Text index for text search
db.articles.createIndex({ content: "text" })

```

## 5. Advanced Searching

MongoDB provides sophisticated search capabilities:

```jsx
// Text search
db.articles.find({ $text: { $search: "mongodb database" } })

// Regular expressions
db.users.find({ name: /^J/ })  // Names starting with J

// Aggregation pipeline for complex searches
db.users.aggregate([
    { $match: { age: { $gt: 25 } } },
    { $group: { _id: "$city", avgAge: { $avg: "$age" } } },
    { $sort: { avgAge: -1 } }
])

```

## 6. Schema Validation

While MongoDB is schema-less, you can enforce document validation rules:

```jsx
db.createCollection("employees", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["name", "email", "hire_date"],
            properties: {
                name: {
                    bsonType: "string",
                    description: "must be a string and is required"
                },
                email: {
                    bsonType: "string",
                    pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
                    description: "must be a valid email address"
                },
                hire_date: {
                    bsonType: "date",
                    description: "must be a date and is required"
                },
                salary: {
                    bsonType: "decimal",
                    minimum: 0,
                    description: "must be a positive decimal"
                }
            }
        }
    }
})

```

## 7. Best Practices

- **Document Design:** Keep documents reasonably sized and avoid deeply nested structures
- **Indexing:** Create indexes to support your queries, but be careful not to create too many
- **Atomicity:** Use atomic operations when possible to ensure data consistency
- **Validation:** Implement schema validation for critical collections
- **Monitoring:** Regularly monitor database performance and query execution plans
- **Backup:** Maintain regular backups and test restoration procedures

Remember that MongoDB's flexible schema design allows for rapid application development and iteration, but it's important to maintain consistent document structures within collections for better maintainability.