# Sealed Classes

# Understanding Sealed Classes in Java

Sealed classes, introduced in Java 17, provide a way to restrict which classes can inherit from a particular class or implement an interface. This feature gives developers more control over class hierarchies and inheritance.

## Basic Concepts

A sealed class explicitly specifies which classes are allowed to extend it using the 'permits' clause.

```java
public sealed class Shape permits Circle, Square, Triangle {
    // Common shape properties and methods
}

public final class Circle extends Shape {
    // Circle implementation
}

public final class Square extends Shape {
    // Square implementation
}

public final class Triangle extends Shape {
    // Triangle implementation
}
```

In this example, only Circle, Square, and Triangle can extend Shape. Any other class attempting to extend Shape will result in a compilation error.

## Rules for Permitted Classes

- All permitted classes must be in the same module as the sealed class
- Permitted classes must extend the sealed class
- Permitted classes must use one of three modifiers:
    - final - Cannot be extended further
    - sealed - Creates another sealed hierarchy
    - non-sealed - Removes the restrictions

## Advanced Usage

You can create more complex hierarchies using nested sealed classes:

```java
public sealed interface Vehicle permits Car, Motorcycle, Truck {
    void move();
}

public sealed class Car implements Vehicle permits ElectricCar, HybridCar {
    @Override
    public void move() {
        System.out.println("Car is moving");
    }
}

public final class ElectricCar extends Car {
    @Override
    public void move() {
        System.out.println("Electric car is moving silently");
    }
}

public non-sealed class HybridCar extends Car {
    @Override
    public void move() {
        System.out.println("Hybrid car is moving");
    }
}
```

## Pattern Matching with Sealed Classes

Sealed classes work particularly well with pattern matching and switch expressions:

```java
public double calculateArea(Shape shape) {
    return switch (shape) {
        case Circle c -> Math.PI * c.radius() * c.radius();
        case Square s -> s.side() * s.side();
        case Triangle t -> (t.base() * t.height()) / 2;
    }; // No default needed - compiler knows all possible cases
}
```

## Benefits of Sealed Classes

- Better type safety and control over class hierarchies
- Enhanced pattern matching capabilities
- Clear documentation of design intentions
- Compiler optimization opportunities

## Common Use Cases

- Domain modeling where you want to restrict possible subtypes
- API design where you need to control extension points
- Pattern matching scenarios where exhaustiveness is important
- Framework development where type hierarchies need to be controlled

Remember that sealed classes are not meant to replace traditional inheritance but rather to provide more control when needed. Use them when you want to explicitly define and restrict the inheritance hierarchy of your classes.