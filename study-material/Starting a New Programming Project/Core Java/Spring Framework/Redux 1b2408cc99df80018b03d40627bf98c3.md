# Redux

# Understanding Redux: State Management for Modern Applications

Redux is a predictable state container for JavaScript applications, designed to help manage complex application state in a consistent and maintainable way.

## Core Concepts and Goals

- **Single Source of Truth:** The entire application state is stored in one central store
- **State is Read-Only:** The only way to change state is by dispatching actions
- **Changes are Made with Pure Functions:** Reducers must be pure functions that take the previous state and an action to return the next state

## Setting Up Redux

First, install the necessary dependencies:

```bash
npm install @reduxjs/toolkit react-redux
# or
yarn add @reduxjs/toolkit react-redux

```

## Basic Implementation in JavaScript

1. Create a store:

```jsx
// store.js
import { configureStore } from '@reduxjs/toolkit'

const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 }
    case 'DECREMENT':
      return { count: state.count - 1 }
    default:
      return state
  }
}

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
})

```

1. Connect Redux to React:

```jsx
// index.js
import { Provider } from 'react-redux'
import { store } from './store'

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)

```

1. Use Redux in a component:

```jsx
// Counter.js
import { useSelector, useDispatch } from 'react-redux'

function Counter() {
  const count = useSelector(state => state.counter.count)
  const dispatch = useDispatch()

  return (
    <div>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
    </div>
  )
}

```

## TypeScript Implementation

1. Define types:

```tsx
// types.ts
interface CounterState {
  count: number
}

type CounterAction = 
  | { type: 'INCREMENT' }
  | { type: 'DECREMENT' }

```

1. Create a typed store:

```tsx
// store.ts
import { configureStore } from '@reduxjs/toolkit'

const initialState: CounterState = { count: 0 }

const counterReducer = (
  state: CounterState = initialState,
  action: CounterAction
): CounterState => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 }
    case 'DECREMENT':
      return { count: state.count - 1 }
    default:
      return state
  }
}

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
})

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch

```

1. Create custom hooks for type safety:

```tsx
// hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'
import type { RootState, AppDispatch } from './store'

export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector

```

1. Use typed Redux in a component:

```tsx
// Counter.tsx
import { useAppSelector, useAppDispatch } from './hooks'

function Counter() {
  const count = useAppSelector(state => state.counter.count)
  const dispatch = useAppDispatch()

  return (
    <div>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
    </div>
  )
}

```

## Best Practices

- **Use Redux Toolkit:** It simplifies common Redux use cases and includes good defaults
- **Keep state minimal:** Only include truly shared state in Redux
- **Use TypeScript:** For better type safety and developer experience
- **Implement selectors:** For efficient state access and computation

## When to Use Redux

Consider using Redux when:

- You have large amounts of application state needed in many places
- The app state updates frequently
- The logic to update state is complex
- The app has a medium or large-sized codebase with many people working on it

Remember that Redux is not always necessary for smaller applications, where simpler state management solutions like React's Context API might be sufficient.