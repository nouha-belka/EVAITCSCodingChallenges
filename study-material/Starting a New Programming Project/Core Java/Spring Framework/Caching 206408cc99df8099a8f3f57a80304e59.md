# Caching

# Understanding Caching in Spring Boot Applications

Caching is a crucial optimization technique that stores frequently accessed data in a fast-access storage layer, reducing database load and improving application performance.

## Core Caching Concepts

- **Cache Hit:** When requested data is found in the cache
- **Cache Miss:** When data must be retrieved from the primary storage
- **Cache Eviction:** The process of removing entries from the cache
- **Cache Consistency:** Ensuring cache data matches the source of truth

## Spring Boot Caching Support

Spring Boot provides robust caching support through its caching abstraction layer.

### Basic Setup

```java
@EnableCaching
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

```

### Key Annotations

- **@Cacheable:** Stores method results in the cache
- **@CacheEvict:** Removes entries from the cache
- **@CachePut:** Updates the cache without affecting method execution
- **@Caching:** Combines multiple cache operations

## Caching Providers

### 1. Redis Cache

Redis is an in-memory data structure store that can be used as a cache, message broker, and queue.

### Redis Configuration

```yaml
spring:
  redis:
    host: localhost
    port: 6379
    timeout: 2000
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 2

```

```java
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}

```

### 2. Memcached

Memcached is a high-performance, distributed memory caching system.

### Memcached Configuration

```java
@Configuration
public class MemcachedConfig {
    @Bean
    public MemcachedClient memcachedClient() {
        return new MemcachedClient(
            new ConnectionFactoryBuilder()
                .setProtocol(ConnectionFactoryBuilder.Protocol.BINARY)
                .build(),
            AddrUtil.getAddresses("localhost:11211")
        );
    }
}

```

## Advanced Caching Strategies

### 1. Multi-Level Caching

```java
@Service
public class UserService {
    @Cacheable(value = "localCache", key = "#id")
    public User getFromLocalCache(Long id) {
        return getFromDistributedCache(id);
    }
    
    @Cacheable(value = "distributedCache", key = "#id")
    public User getFromDistributedCache(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}

```

### 2. Cache Synchronization

```java
@Service
public class ProductService {
    @Caching(
        evict = {@CacheEvict(value = "products", key = "#product.id")},
        put = {@CachePut(value = "products", key = "#product.id")}
    )
    public Product updateProduct(Product product) {
        return productRepository.save(product);
    }
}

```

## Best Practices and Guidelines

### 1. Cache Key Design

- **Use meaningful keys:** Include relevant identifiers and version information
- **Consider key length:** Balance between readability and storage efficiency
- **Include version numbers:** Help manage cache invalidation

```java
@Cacheable(value = "users", key = "#root.target.CLASS_VERSION + '_' + #id")
public User getUser(Long id) {
    private static final String CLASS_VERSION = "v1.0";
    // implementation
}

```

### 2. Error Handling

```java
@Cacheable(value = "products", unless = "#result == null")
public Product getProduct(Long id) {
    try {
        return productRepository.findById(id)
            .orElseThrow(() -> new ProductNotFoundException(id));
    } catch (Exception e) {
        log.error("Cache operation failed", e);
        return null;
    }
}

```

## Performance Optimization

- **Cache Warm-up Strategy:**
    
    ```java
    @PostConstruct
    public void warmUpCache() {
        List<User> frequentUsers = userRepository.findFrequentUsers();
        frequentUsers.forEach(user -> 
            cacheManager.getCache("users").put(user.getId(), user));
    }
    ```
    

## Common Interview Questions

1. What is the difference between @Cacheable and @CachePut?**Answer:** @Cacheable first checks the cache before method execution and skips it if there's a cache hit, while @CachePut always executes the method and updates the cache with the result.
2. How do you handle cache invalidation in a distributed system?**Answer:** Common strategies include:
- Using TTL (Time-To-Live)
- Implementing event-driven cache updates
- Using cache versioning
- Implementing a distributed cache like Redis with pub/sub capabilities
3. What are the pros and cons of using Redis vs Memcached?**Answer:**
Redis:
Pros:
- Data persistence
- Complex data structures
- Built-in clustering
- Pub/sub messaging

Cons:
- Higher memory usage
- More complex setup

Memcached:
Pros:
- Simpler architecture
- Lower memory overhead
- Better for simple caching

Cons:
- No data persistence
- Limited data structures
- Basic clustering
4. How would you prevent cache stampede?**Answer:**
- Implement sliding window expiration
- Use background refresh
- Implement probabilistic early expiration
- Use lock mechanisms for cache population

## Monitoring and Maintenance

### 1. Cache Metrics

```java
@Configuration
public class CacheMetricsConfig {
    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }
    
    @Bean
    public CacheMetricsRegistrar cacheMetricsRegistrar(MeterRegistry registry) {
        return new CacheMetricsRegistrar(registry);
    }
}

```

### 2. Health Checks

```java
@Component
public class CacheHealthIndicator extends AbstractHealthIndicator {
    @Override
    protected void doHealthCheck(Health.Builder builder) {
        try {
            // Perform cache connectivity check
            builder.up();
        } catch (Exception e) {
            builder.down(e);
        }
    }
}

```

This comprehensive guide covers the essential aspects of caching in Spring Boot applications. Remember that caching is not a one-size-fits-all solution, and careful consideration should be given to your specific use case when implementing a caching strategy.

## Caching Theory and Fundamentals

Understanding the theoretical foundations of caching is crucial for implementing effective caching strategies.

### Cache Coherence

Cache coherence refers to the consistency of shared resource data that is stored in multiple caches. In distributed systems, maintaining cache coherence is crucial for data consistency.

- **Write-Through vs Write-Back:**
    - Write-Through: Data is written to both cache and main storage simultaneously
    - Write-Back: Data is initially written only to cache and later synchronized with main storage

### Cache Replacement Policies

When a cache is full, a replacement policy determines which items to remove to make space for new entries.

- **Common Replacement Algorithms:**
    - LRU (Least Recently Used)
    - LFU (Least Frequently Used)
    - FIFO (First In, First Out)
    - Random Replacement

### Cache Aside Pattern

```java
public class CacheAsidePattern {
    public Data getDataWithCacheAside(String key) {
        // Try cache first
        Data data = cache.get(key);
        if (data == null) {
            // Cache miss - read from DB
            data = database.get(key);
            // Update cache
            cache.put(key, data);
        }
        return data;
    }
}

```

### Write-Through Pattern

```java
public class WriteThroughPattern {
    public void updateDataWriteThrough(String key, Data data) {
        // Update DB first
        database.put(key, data);
        // Update cache
        cache.put(key, data);
    }
}

```

### Cache Loading Strategies

- **Lazy Loading:** Load data into cache only when first requested
- **Eager Loading:** Preload cache with anticipated data
- **Refresh Ahead:** Automatically refresh cache entries before expiration

### Distributed Caching Considerations

- **Partition Tolerance:** System continues to operate despite network partitions
- **Replication:** Data is copied across multiple cache nodes
- **Consistency Models:** Strong, eventual, or other consistency approaches

### Cache Statistics and Metrics

```java
@Component
public class CacheMetrics {
    private final MeterRegistry registry;
    
    public void recordCacheHit(String cacheName) {
        registry.counter("cache.hits", "name", cacheName).increment();
    }
    
    public void recordCacheMiss(String cacheName) {
        registry.counter("cache.misses", "name", cacheName).increment();
    }
}

```

Understanding these theoretical aspects helps in making informed decisions about caching strategies and implementing them effectively in production systems.

[Redis](Caching/Redis%20206408cc99df806c821bcc55f7c02578.md)

[Memcached](Caching/Memcached%20206408cc99df80e0a8c9c7af7ba0696b.md)