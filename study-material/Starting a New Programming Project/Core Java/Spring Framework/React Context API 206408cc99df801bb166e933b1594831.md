# React Context API

# Understanding React Context API

The Context API is a React feature that enables sharing state across components without prop drilling. It provides a way to pass data through the component tree without manually passing props at every level.

## Core Concepts

- **Context:** A mechanism to share values between components without explicitly passing props
- **Provider:** A component that supplies the state to its children
- **Consumer:** Components that consume and use the context data

## Important Hooks

- **useContext:** Hook to consume context in functional components
- **useState:** Often used with Context to manage state
- **useReducer:** For complex state management scenarios with Context

## Basic Setup in JavaScript

```jsx
// Create context
const ThemeContext = React.createContext();

// Provider Component
const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Consumer Component
const ThemedButton = () => {
  const { theme, setTheme } = useContext(ThemeContext);
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
};
```

## TypeScript Implementation

```tsx
// Define context type
interface ThemeContextType {
  theme: string;
  setTheme: (theme: string) => void;
}

// Create context with type
const ThemeContext = React.createContext<ThemeContextType | undefined>(undefined);

// Provider Component
const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<string>('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Custom hook for type safety
const useTheme = (): ThemeContextType => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

// Consumer Component
const ThemedButton: React.FC = () => {
  const { theme, setTheme } = useTheme();
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
};
```

## Best Practices

- **Context Composition:** Use multiple contexts instead of one large context
- **Performance Optimization:** Split contexts based on update frequency
- **Error Boundaries:** Implement error handling for undefined contexts
- **Custom Hooks:** Create dedicated hooks for consuming context

## Common Use Cases

- Theme switching
- User authentication state
- Language/localization preferences
- Global UI state management

While Context API is powerful for simple state management, consider using more robust solutions like Redux or MobX for complex applications with frequent updates and large state trees.