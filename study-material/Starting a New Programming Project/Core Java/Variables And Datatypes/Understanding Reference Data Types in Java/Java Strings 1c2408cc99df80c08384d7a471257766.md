# Java Strings

# Understanding Java Strings in Depth

## What are Strings?

In Java, String is a reference type that represents a sequence of characters. Unlike many other programming languages, Java treats Strings as immutable objects, which has important implications for how they are handled in memory and during operations.

## String Creation and Memory Management

```java
// String literal creation
String str1 = "Hello";

// String object creation
String str2 = new String("Hello");

// String concatenation
String str3 = "Hello" + " World";

```

### The String Pool

The String pool (also known as String intern pool) is a special memory area in Java's heap memory. When we create a String using literals, Java first checks if an identical String exists in the pool:

```java
String s1 = "Hello";           // Creates new String in pool
String s2 = "Hello";           // Reuses existing String from pool
String s3 = new String("Hello"); // Creates new object outside pool

System.out.println(s1 == s2);      // true (same reference)
System.out.println(s1 == s3);      // false (different reference)
System.out.println(s1.equals(s3)); // true (same content)

```

### String Immutability

Strings in Java are immutable for several important reasons:

- Security: String parameters can't be altered by methods they're passed to
- Thread Safety: Multiple threads can safely share String objects
- String Pool Optimization: Enables safe reuse of String objects
- Hash Code Caching: Immutability allows caching of hash codes for better performance

## Essential String Methods

### String Comparison Methods

```java
String text = "Hello World";

// Comparison methods
boolean equals = text.equals("Hello World");     // true
boolean ignoreCase = text.equalsIgnoreCase("hello world"); // true
int comparison = text.compareTo("Hello");        // Returns positive number

```

### String Manipulation Methods

```java
String text = "Hello World";

// Substring operations
String sub = text.substring(0, 5);      // "Hello"
String lower = text.toLowerCase();       // "hello world"
String upper = text.toUpperCase();       // "HELLO WORLD"
String trimmed = "  text  ".trim();      // "text"

// Search operations
int index = text.indexOf("World");       // 6
boolean starts = text.startsWith("Hello"); // true
boolean ends = text.endsWith("World");    // true
boolean contains = text.contains("lo");    // true

```

### String Modification Methods

```java
String text = "Hello World";

// Replace operations
String replaced = text.replace('l', 'L');         // "HeLLo WorLd"
String replacedAll = text.replaceAll("l", "L");   // "HeLLo WorLd"
String firstReplaced = text.replaceFirst("l", "L"); // "HeLlo World"

// Split and join
String[] parts = text.split(" ");                 // ["Hello", "World"]
String joined = String.join("-", parts);          // "Hello-World"

```

## Performance Considerations

### String Concatenation

```java
// Inefficient way (creates multiple String objects)
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i;
}

// Efficient way using StringBuilder
StringBuilder builder = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    builder.append(i);
}
String result = builder.toString();

```

### When to Use Different String Classes

- **String:** Use when the value won't change and immutability is desired
- **StringBuilder:** Use for mutable strings in single-threaded environments
- **StringBuffer:** Use for mutable strings in multi-threaded environments where synchronization is needed

## Common String Operations and Best Practices

```java
// String formatting
String formatted = String.format("Hello, %s! You are %d years old.", "John", 25);

// StringBuilder for efficient concatenation
StringBuilder builder = new StringBuilder();
builder.append("Hello")
       .append(" ")
       .append("World");
String result = builder.toString();

// Using intern() method
String str1 = new String("Hello").intern();
String str2 = "Hello";
System.out.println(str1 == str2); // true after interning

```

## Common Pitfalls to Avoid

- Using == instead of equals() for String comparison
- Inefficient String concatenation in loops
- Not considering character encoding when working with Strings
- Unnecessary String object creation