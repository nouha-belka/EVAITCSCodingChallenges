# Generics

# Understanding Java Generics

Generics were introduced in Java 5.0 to provide compile-time type safety and eliminate the need for explicit type casting. They enable you to write code that can work with different types while maintaining type safety.

## Key Benefits of Generics

- **Type Safety:** Catches type errors at compile time rather than runtime, preventing ClassCastExceptions
- **Code Reusability:** Write a single class/method that can work with different types
- **Type Erasure:** Removes type parameters at runtime for backward compatibility
- **Elimination of Type Casting:** Reduces boilerplate code and potential runtime errors

## Basic Syntax

```java
// Generic Class
public class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}

// Usage
Box<String> stringBox = new Box<>();
stringBox.set("Hello Generics!");
String content = stringBox.get(); // No casting needed
```

## Type Parameters Conventions

- **T** - Type
- **E** - Element
- **K** - Key
- **V** - Value
- **N** - Number

## Advanced Features

### 1. Bounded Type Parameters

```java
public class NumberBox<T extends Number> {
    private T number;
    
    public double sqrt() {
        return Math.sqrt(number.doubleValue());
    }
}
```

### 2. Wildcard Types

```java
// Upper Bounded Wildcard
void processNumbers(List<? extends Number> numbers) { }

// Lower Bounded Wildcard
void addNumbers(List<? super Integer> numbers) { }

// Unbounded Wildcard
void printList(List<?> list) { }
```

## Best Practices

- **Use Generics for Collections:** Always specify the type parameter when using collections to ensure type safety
- **Favor Generic Methods:** Make methods generic instead of forcing clients to cast types
- **Use Bounded Type Parameters:** When you need to restrict the types that can be used with your generic class or method
- **Consider Type Erasure:** Be aware that type information is not available at runtime due to type erasure

## Common Use Cases

- Collection classes (ArrayList, HashMap, etc.)
- Utility classes that operate on different types
- Factory methods returning different types
- Data structures (custom implementations)

## Impact on Software Engineering

Generics make us better engineers by:

- Encouraging type-safe programming practices
- Reducing code duplication and promoting DRY principles
- Catching errors at compile-time rather than runtime
- Improving code readability and maintainability
- Enabling the creation of more robust and reusable components

## Common Pitfalls

- **Raw Types:** Avoid using raw types as they bypass generic type checking
- **Type Erasure Limitations:** Cannot create arrays of generic types or use instanceof with generic types
- **Overloading:** Be careful with method overloading due to type erasure

Understanding and properly implementing generics is crucial for modern Java development, as it leads to more maintainable, type-safe, and efficient code.