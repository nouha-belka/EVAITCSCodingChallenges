# Records

# Java Records: A Guide to Immutable Data Classes

## Historical Context: Immutable Classes in Java

Before Java 14, creating immutable classes required writing significant boilerplate code. Developers had to manually implement:

- Private final fields
- Constructor for initialization
- Getter methods for each field
- equals() and hashCode() methods
- toString() method

## Traditional Immutable Class Example

```java
public final class Person {
    private final String name;
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public int getAge() { return age; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {
        return "Person[name=" + name + ", age=" + age + "]";
    }
}
```

## Introduction to Records (Java 14+)

Records were introduced in Java 14 (preview) and became permanent in Java 16. They provide a concise way to declare classes that are transparent holders for immutable data.

## Record Example

```java
public record Person(String name, int age) {}
```

This simple declaration automatically provides:

- Private, final fields for each component
- A canonical constructor
- Public accessor methods
- equals(), hashCode(), and toString() implementations

## Use Cases for Records

- **Data Transfer Objects (DTOs):** Perfect for transferring data between different layers of an application
- **API Responses:** Ideal for representing API response structures
- **Value Objects:** When you need immutable objects that represent values rather than entities
- **Tuple-like Data Groups:** When you need to group related data together

## Best Practices

- **Keep Records Focused:** Records should represent simple data aggregates
- **Immutable Components:** Use immutable types for record components when possible
- **Validation in Canonical Constructor:** Add validation using compact constructor syntax

## Advanced Record Features

```java
public record Person(String name, int age) {
    // Compact constructor for validation
    public Person {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Name cannot be empty");
        }
    }

    // Additional methods are allowed
    public boolean isAdult() {
        return age >= 18;
    }
}
```

## Records vs Classes

Key differences between records and traditional classes:

- Records are implicitly final and cannot be abstract
- Records cannot extend other classes (but can implement interfaces)
- All fields are final and private
- Records cannot declare instance fields other than the components in the header

## Common Patterns

```java
// Nested Records
public record Department(String name, List<Person> employees) {
    // Defensive copying for mutable components
    public Department {
        employees = List.copyOf(employees);
    }
}

// Generic Records
public record Pair<T, U>(T first, U second) {}

// Records with static factory methods
public record Range(int start, int end) {
    public static Range of(int start, int end) {
        if (end < start) {
            throw new IllegalArgumentException("End must be >= start");
        }
        return new Range(start, end);
    }
}
```

## Performance Considerations

Records are designed to be memory-efficient and perform well in most scenarios. They are particularly efficient when:

- Used as temporary data carriers
- In stream operations
- As map keys (due to proper equals/hashCode implementation)

Records have become an essential feature for modern Java development, significantly reducing boilerplate code while ensuring data immutability and proper encapsulation.