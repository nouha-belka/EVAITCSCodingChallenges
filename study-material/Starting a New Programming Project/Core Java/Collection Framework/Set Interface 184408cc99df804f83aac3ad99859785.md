# Set Interface

# Set Interface in Java

A Set is a Collection that cannot contain duplicate elements. It models the mathematical set abstraction and is one of the fundamental interfaces in the Java Collections Framework.

## Key Characteristics

- **No Duplicates:** Sets automatically handle duplicate elimination. When you try to add a duplicate element, the add operation returns false.
- **Null Elements:** Some Set implementations permit null elements (HashSet, LinkedHashSet) while others don't (TreeSet)
- **Unordered:** Most Set implementations don't guarantee the order of elements (except for TreeSet and LinkedHashSet)

## Set Implementations

### 1. HashSet

The most commonly used Set implementation, backed by a hash table (HashMap instance).

- **Performance:** O(1) for basic operations (add, remove, contains)
- **Order:** Does not maintain insertion order
- **Use when:** You need the fastest possible performance and don't care about order

```java
HashSet<String> hashSet = new HashSet<>();
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Apple");  // Won't be added (duplicate)
System.out.println(hashSet);  // Output: [Banana, Apple] (order not guaranteed)
```

### 2. TreeSet

A NavigableSet implementation based on a TreeMap. Elements are stored in sorted order.

- **Performance:** O(log n) for basic operations
- **Order:** Maintains natural ordering or uses a custom Comparator
- **Use when:** You need elements in sorted order

```java
TreeSet<Integer> treeSet = new TreeSet<>();
treeSet.add(3);
treeSet.add(1);
treeSet.add(2);
System.out.println(treeSet);  // Output: [1, 2, 3] (always sorted)
```

### 3. LinkedHashSet

Hash table and linked list implementation of the Set interface.

- **Performance:** O(1) for basic operations
- **Order:** Maintains insertion order
- **Use when:** You need fast performance and insertion-order preservation

```java
LinkedHashSet<String> linkedSet = new LinkedHashSet<>();
linkedSet.add("First");
linkedSet.add("Second");
linkedSet.add("Third");
System.out.println(linkedSet);  // Output: [First, Second, Third] (insertion order preserved)
```

## Common Set Operations

Sets support mathematical set operations:

```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> set2 = new HashSet<>(Arrays.asList(2, 3, 4));

// Union
set1.addAll(set2);  // set1 now contains [1, 2, 3, 4]

// Intersection
set1.retainAll(set2);  // set1 now contains only elements present in both sets

// Difference
set1.removeAll(set2);  // set1 now contains elements not in set2

// Check subset
boolean isSubset = set1.containsAll(set2);
```

## Best Practices

- **Choose the right implementation:** Use HashSet for general purposes, TreeSet for sorted data, LinkedHashSet for ordered access
- **Initial capacity:** Specify initial capacity if you know the approximate number of elements to avoid resizing
- **Custom objects:** Override equals() and hashCode() methods when using custom objects in Sets
- **Thread safety:** Use Collections.synchronizedSet() if thread safety is needed

## Common Pitfalls

- **Modifying elements:** Don't modify objects after adding them to a HashSet (it affects their hash code)
- **Comparison consistency:** Ensure compareTo() is consistent with equals() for TreeSet
- **Null elements:** Be careful with null elements, especially in TreeSet which doesn't allow them

Sets are essential when you need to maintain a collection of unique elements. Choose the appropriate implementation based on your specific requirements for ordering, performance, and functionality.