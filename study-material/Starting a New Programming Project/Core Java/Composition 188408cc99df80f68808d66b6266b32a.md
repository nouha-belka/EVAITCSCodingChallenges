# Composition

# Understanding Composition in Java

Composition is a fundamental concept in Object-Oriented Programming where a class is composed of one or more objects of other classes. Think of it as a "has-a" relationship between objects.

## Real-Life Example

Consider a car: A car has-a engine, has-a steering wheel, and has-a transmission system. The car isn't any of these things by itself, but it contains these components to function.

```java
// Component classes
class Engine {
    private String type;
    private int horsepower;
    
    public Engine(String type, int horsepower) {
        this.type = type;
        this.horsepower = horsepower;
    }
    
    public void start() {
        System.out.println("Engine started");
    }
}

class SteeringWheel {
    private String material;
    
    public SteeringWheel(String material) {
        this.material = material;
    }
    
    public void turn(String direction) {
        System.out.println("Turning " + direction);
    }
}

// Composite class
class Car {
    private Engine engine;        // Composition
    private SteeringWheel wheel;  // Composition
    
    public Car() {
        engine = new Engine("V8", 300);
        wheel = new SteeringWheel("Leather");
    }
    
    public void startCar() {
        engine.start();
    }
    
    public void turnCar(String direction) {
        wheel.turn(direction);
    }
}
```

## Code Explanation

- **Component Classes:** Engine and SteeringWheel are independent classes that represent parts of a car
- **Composite Class:** Car is composed of Engine and SteeringWheel objects
- **Lifetime Management:** The lifetime of component objects (engine, wheel) is tied to the Car object

## Benefits of Composition

- **Reusability:** Components can be reused in different composite classes
- **Flexibility:** Components can be easily modified without affecting the composite class
- **Encapsulation:** Internal details of components are hidden from the composite class

## Composition vs Inheritance

While inheritance represents an "is-a" relationship, composition represents a "has-a" relationship. For example:

- Inheritance: A Car is-a Vehicle (extends Vehicle)
- Composition: A Car has-a Engine (contains Engine)

## Best Practices

- Favor composition over inheritance when possible
- Use composition to implement loose coupling between classes
- Ensure proper cleanup of composed objects when needed

## Another Example: Smart Home System

```java
class Light {
    private boolean isOn;
    
    public void turnOn() {
        isOn = true;
        System.out.println("Light is on");
    }
    
    public void turnOff() {
        isOn = false;
        System.out.println("Light is off");
    }
}

class Thermostat {
    private int temperature;
    
    public void setTemperature(int temp) {
        this.temperature = temp;
        System.out.println("Temperature set to " + temp);
    }
}

class SmartHome {
    private Light livingRoomLight;
    private Light kitchenLight;
    private Thermostat thermostat;
    
    public SmartHome() {
        livingRoomLight = new Light();
        kitchenLight = new Light();
        thermostat = new Thermostat();
    }
    
    public void eveningMode() {
        livingRoomLight.turnOn();
        kitchenLight.turnOff();
        thermostat.setTemperature(22);
    }
}
```

## Advanced Composition Concepts

### 1. Aggregation vs Composition

While both are "has-a" relationships, they differ in object lifetime management:

- **Composition:** Strong relationship where child cannot exist without parent (Car-Engine)
- **Aggregation:** Weak relationship where child can exist independently (University-Student)

### 2. Example of Aggregation

```java
class Student {
    private String name;
    private int id;
    
    public Student(String name, int id) {
        this.name = name;
        this.id = id;
    }
}

class University {
    private List<Student> students; // Aggregation
    
    public University() {
        students = new ArrayList<>();
    }
    
    public void addStudent(Student student) {
        students.add(student);
    }
}
```

### 3. Dependency Injection

A design pattern often used with composition to increase flexibility and testability:

```java
class Computer {
    private CPU cpu;
    private RAM ram;
    
    // Constructor injection
    public Computer(CPU cpu, RAM ram) {
        this.cpu = cpu;
        this.ram = ram;
    }
    
    // Setter injection
    public void upgradeCPU(CPU newCPU) {
        this.cpu = newCPU;
    }
}
```

### 4. Common Design Patterns Using Composition

- **Decorator Pattern:** Adds behavior to objects dynamically
- **Composite Pattern:** Treats individual objects and compositions uniformly
- **Strategy Pattern:** Enables switching between different algorithms

## Performance Considerations

- **Memory Management:** Composed objects are created and destroyed together
- **Lazy Loading:** Initialize components only when needed
- **Thread Safety:** Consider synchronization when sharing composed objects

## Testing Composition

```java
class CompositionTest {
    @Test
    public void testCarComposition() {
        Car car = new Car();
        car.startCar();  // Should start the engine
        car.turnCar("left");  // Should turn the wheel
        
        // Mock objects can be used for testing components independently
        Engine mockEngine = mock(Engine.class);
        SteeringWheel mockWheel = mock(SteeringWheel.class);
        
        Car testCar = new Car(mockEngine, mockWheel);
        testCar.startCar();
        
        verify(mockEngine).start();  // Verify the mock was called
    }
}
```

This expanded guide covers more advanced aspects of composition, including real-world examples, design patterns, and testing strategies. Understanding these concepts will help you write more maintainable and flexible code.