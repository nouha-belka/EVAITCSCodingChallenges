# JUnit

# Introduction to JUnit

JUnit is a fundamental testing framework for Java applications, much like a quality control inspector in a manufacturing plant. Just as inspectors check products for defects before they reach customers, JUnit helps developers verify their code works correctly before deployment.

## Practical Examples with Code

### 1. Basic Calculator Testing

Let's start with testing a simple Calculator class:

```java
// Calculator.java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public int subtract(int a, int b) {
        return a - b;
    }
    
    public int multiply(int a, int b) {
        return a * b;
    }
    
    public double divide(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("Cannot divide by zero!");
        }
        return (double) a / b;
    }
}

// CalculatorTest.java
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
    private Calculator calculator;
    
    @BeforeEach
    void setUp() {
        calculator = new Calculator();
    }
    
    @Test
    void testAddition() {
        assertEquals(4, calculator.add(2, 2), "2 + 2 should equal 4");
    }
    
    @Test
    void testDivisionByZero() {
        assertThrows(IllegalArgumentException.class, 
            () -> calculator.divide(10, 0),
            "Dividing by zero should throw IllegalArgumentException"
        );
    }
}
```

In this example, we see several key testing concepts:

- **@BeforeEach:** Sets up a fresh Calculator instance before each test, ensuring test independence
- **assertEquals:** Verifies the actual result matches the expected result
- **assertThrows:** Checks if the code throws the expected exception

### 2. Banking Account Example

```java
// BankAccount.java
public class BankAccount {
    private double balance;
    private String accountHolder;
    
    public BankAccount(String accountHolder, double initialBalance) {
        this.accountHolder = accountHolder;
        this.balance = initialBalance;
    }
    
    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive");
        }
        balance += amount;
    }
    
    public void withdraw(double amount) {
        if (amount > balance) {
            throw new InsufficientFundsException("Not enough balance");
        }
        balance -= amount;
    }
    
    public double getBalance() {
        return balance;
    }
}

// BankAccountTest.java
@DisplayName("Bank Account Tests")
class BankAccountTest {
    private BankAccount account;
    
    @BeforeEach
    void init() {
        account = new BankAccount("John Doe", 1000.0);
    }
    
    @Test
    @DisplayName("Deposit increases balance")
    void testDeposit() {
        account.deposit(500.0);
        assertEquals(1500.0, account.getBalance(), 
            "Balance should be 1500.0 after depositing 500.0");
    }
    
    @Test
    @DisplayName("Multiple operations work correctly")
    void testMultipleOperations() {
        account.deposit(200.0);
        account.withdraw(50.0);
        account.deposit(100.0);
        assertEquals(1250.0, account.getBalance(), 
            "Balance should be correct after multiple operations");
    }
    
    @ParameterizedTest
    @ValueSource(doubles = {-100.0, -50.0, -1.0, 0.0})
    @DisplayName("Invalid deposits throw exception")
    void testInvalidDeposits(double invalidAmount) {
        assertThrows(IllegalArgumentException.class,
            () -> account.deposit(invalidAmount),
            "Invalid deposits should throw exception");
    }
}
```

### 3. Testing with Timeouts

```java
@Test
@Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
void testDatabaseQuery() {
    // This test will fail if it takes longer than 100ms
    database.executeQuery("SELECT * FROM users");
}
```

### 4. Repeated Tests

```java
@RepeatedTest(5)
void repeatedTest() {
    // This test will run 5 times
    assertTrue(new Random().nextInt(10) < 10);
}
```

## Advanced Testing Patterns

### 1. Test Data Builder Pattern

```java
public class UserBuilder {
    private String name = "Default";
    private int age = 30;
    private String email = "default@example.com";
    
    public UserBuilder withName(String name) {
        this.name = name;
        return this;
    }
    
    public UserBuilder withAge(int age) {
        this.age = age;
        return this;
    }
    
    public User build() {
        return new User(name, age, email);
    }
}

@Test
void testUserCreation() {
    User user = new UserBuilder()
        .withName("Alice")
        .withAge(25)
        .build();
    
    assertEquals("Alice", user.getName());
    assertEquals(25, user.getAge());
}
```

These examples demonstrate how JUnit can be used to thoroughly test different aspects of your code. Remember to:

- Write tests that cover both normal scenarios and edge cases
- Use descriptive test names that explain the scenario being tested
- Keep tests independent and focused on a single aspect of functionality
- Use appropriate assertions for different types of verifications